// WDAFile.cpp: implementation of the WDAFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <algorithm>
#include "WDAFile.h"
#include "Format.h"
#include "Random.h"

using namespace std;
using namespace vir;

// Construction //////////////////////////////////////////////////////////////////////////
WDAFileException::WDAFileException
//////////////////////////////////////////////////////////////////////////////////////////
(
 std::string csExplain, // The textual explanation of the exception.
 ErrorType error        // The error code of the exception
)
//////////////////////////////////////////////////////////////////////////////////////////
: errorType( error ), csExplanation( csExplain ){}

// Accessors
//////////////////////////////////////////////////////////////////////////////////////////
WDAFileException::ErrorType WDAFileException::GetError( void )
//////////////////////////////////////////////////////////////////////////////////////////
//  Returns the error type
//////////////////////////////////////////////////////////////////////////////////////////
{
    return errorType;
}
//////////////////////////////////////////////////////////////////////////////////////////
std::string &WDAFileException::GetExplanation( void )
//////////////////////////////////////////////////////////////////////////////////////////
// Returns the textual explanation of the exception
//////////////////////////////////////////////////////////////////////////////////////////
{
    return csExplanation;
}

// File-scope functions and data.
namespace{
//////////////////////////////////////////////////////////////////////////////////////////
inline BYTE GetRandomByte
//////////////////////////////////////////////////////////////////////////////////////////
//  Helper function, returns a random byte.
// 
(
 DWORD dwSeed // The seed.
)
// Return: inline BYTE, The byte.
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Create a static structure that will be initialized the first time the function is called.
    static struct RandomBuffer{
        // Statically create the random buffer at initialization time.
        RandomBuffer(){
            DWORD i;
            // Initialize the random buffer.
            Random rnd;
            rnd.SetSeed( 23422 );
            for( i = 0; i < BufferSize; i++ ){
                pbRandom[ i ] = rnd( 0, 255 );
            }                
        }

        inline BYTE GetRandomByte( DWORD dwSeed ){
            return pbRandom[ dwSeed % BufferSize ];
        }

    private:
        enum{ BufferSize = 3418 };
        BYTE pbRandom[ BufferSize ];
    } cRandomBuffer;
    
    return cRandomBuffer.GetRandomByte( dwSeed );
}
}; // namespace


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

WDAFile::WDAFile()
{
    fFile = NULL;
}

WDAFile::~WDAFile()
{
    Close();    
}

//////////////////////////////////////////////////////////////////////////////////////////
bool WDAFile::Create
//////////////////////////////////////////////////////////////////////////////////////////
//  Creates a WDAFile, truncates any existing one.
// 
(
 string csPath // The patch where the WDA file should be created
)
// Return: bool, true if open succeeded.
//////////////////////////////////////////////////////////////////////////////////////////
{
    fFile = fopen( csPath.c_str(), "wb+" );
    return fFile != NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////
bool WDAFile::Open
//////////////////////////////////////////////////////////////////////////////////////////
//  Opens a file for reading and writing.
// 
(
 string csPath // The path of the file.
)
// Return: bool, true if open succeeded.
//////////////////////////////////////////////////////////////////////////////////////////
{
    fFile = fopen( csPath.c_str(), "rb+" );
    if( fFile == NULL ){
        return false;
    }
    
    fseek( fFile, 0, SEEK_SET );

    return true;
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Close( void )
//////////////////////////////////////////////////////////////////////////////////////////
//  Closes the file. This function is automatically called on destruction.
// 
//////////////////////////////////////////////////////////////////////////////////////////
{
    if( fFile != NULL ){
        fclose( fFile );
        fFile = NULL;
    }

}

// Encryption/Decryption
//////////////////////////////////////////////////////////////////////////////////////////
BYTE WDAFile::Encrypt
//////////////////////////////////////////////////////////////////////////////////////////
// Encrypts a byte and returns the encrypted value
// 
(
 const BYTE bByte, // The byte to encrypt.
 DWORD dwSeed
)
// Return: BYTE, the encrypted byte.
//////////////////////////////////////////////////////////////////////////////////////////
{
    return bByte ^ GetRandomByte( dwSeed );
}


//////////////////////////////////////////////////////////////////////////////////////////
BYTE WDAFile::Decrypt
//////////////////////////////////////////////////////////////////////////////////////////
//  Decrypts the byte and returns the decrypted value
// 
(
 const BYTE bByte, // The byte to decrypt.
 DWORD dwSeed
)
// Return: BYTE, The decrypted value.
//////////////////////////////////////////////////////////////////////////////////////////
{
    return bByte ^ GetRandomByte( dwSeed );
}

// Writing.
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Writes a buffer to the file
// 
(
 const void *lpBuffer, // The buffer to write.
 DWORD dwSize    // The size of the buffer to write.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Buffer is NULL ? You cannot pass NULL to this function.
    ASSERT( lpBuffer != NULL );

    const BYTE *pbBuffer = reinterpret_cast< const BYTE * >( lpBuffer );
    
    // Write the buffer to the file.
    DWORD i;
    DWORD dwOffset = ftell( fFile );
    // We need to do a character-by-character write for stream encryption.
    for( i = 0; i < dwSize; i++ ){
        // If fputc fails
        if( fputc( Encrypt( pbBuffer[ i ], i + dwOffset ), fFile ) == EOF ){

            // Writing failed!
            ASSERT( false );

            // Throw a WriteError exception.
            static WDAFileException ex( "Error writting to file", WDAFileException::WriteError );
            throw( ex );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Writes a DWORD to the file.
// 
(
 DWORD dwDword // The DWORD to write.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Write the DWORD's buffer.
    Write( &dwDword, sizeof( DWORD ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Writes a WORD to the file.
// 
(
 WORD wWord // The WORD to write.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Write the WORD's buffer.
    Write( &wWord, sizeof( WORD ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Writes a string to the file.
// 
(
 const std::string &csString // Writes a string to the file.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Write the string's size.    
    Write( static_cast< DWORD >( csString.size() ) );
    
    // Write the string.
    Write( csString.data(), csString.size() );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
// 
// 
(
 BYTE bByte // Writes a byte to the file.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Write the byte
    Write( &bByte, sizeof( BYTE ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Writes a boolean to the file.
// 
(
 bool boBool // The boolean to write.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Copy the bool into a BYTE.
    BYTE bByte = boBool ? 1 : 0;

    // Write that byte. Can only be 1 or 0.
    Write( &bByte, sizeof( BYTE ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
// Writes to a signed int.
// 
(
 signed int  nInt // The int.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Write( &nInt, sizeof( signed int ) );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
// Writes a long to the wdaFile
// 
(
 signed long lLong // The long
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Write( &lLong, sizeof( signed long ) );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
// Writes a char to the wdaFile
// 
(
 signed char cChar // The signed char.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Write( &cChar, sizeof( signed char ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Write a short.
// 
(
 signed short sShort // The short.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Write( &sShort, sizeof( signed short ) );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Write
//////////////////////////////////////////////////////////////////////////////////////////
//  Writes a double to a wdaFile
// 
(
 double dblDouble // The wdaFile
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Write( &dblDouble, sizeof( double ) );
}

// Reading.
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read 
//////////////////////////////////////////////////////////////////////////////////////////
//  Reads from a buffer.
// 
(
 void *lpBuffer, // The provided buffer, must at least be dwSize bytes long!
 DWORD dwSize,    // The size of the buffer.
 const char *szExceptionText // Text for the end-of-file exception.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    BYTE *pbBuffer = static_cast< BYTE * >( lpBuffer );
    
    DWORD i;
    int ch;
    DWORD dwOffset = ftell( fFile );

    // Do a character-by-character read for stream decryption.
    for( i = 0; i < dwSize; i++ ){
        ch = fgetc( fFile );
        
        // End of file reached? You should NEVER read passed the end of file with a WDAFile
        ASSERT( ch != EOF );        

        // If the file is empty, kick-in the run-time exception mechanism.
        if( ch == EOF ){
            TFormat cFormat;

            static WDAFileException ex( 
                cFormat(
                    "End-of-File reached reading from %s.",
                    szExceptionText
                ), 
                WDAFileException::EndOfFile
            );
            // Throw an end-of-file exception.
            throw( ex );
        }

        // Decrypt character.
        ch = Decrypt( ch, i + dwOffset );

        // Append character to buffer.
        pbBuffer[ i ] = static_cast< BYTE >( ch );
    }

}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read 
//////////////////////////////////////////////////////////////////////////////////////////
// Reads a DWORD from the wdaFile
// 
(
 DWORD &dwDword // The DWORD in which to put the value.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &dwDword, sizeof( DWORD ), "a DWORD" );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
// Reads a WORD from the WDAFile
// 
(
 WORD  &wWord // The WORD in which to put the value.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &wWord, sizeof( WORD ), "a WORD" );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
// Reads a string from the WDAFile
// 
(
 std::string &csString // The string.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    DWORD dwStringSize = 0xABCD;

    // Read the string size.
    Read( dwStringSize );

    // The string size wasn't fetched!
    ASSERT( dwStringSize != 0xABCD );
    
    // Create a new buffer to hold the string.
    auto_ptr< char > apBuffer( new char[ dwStringSize + 1 ] );

    // Read the string from the file.
    Read( apBuffer.get(), dwStringSize, "a string" );

    // NULL terminate the string.
    apBuffer.get()[ dwStringSize ] = 0;

    // Assign this buffer to the string.
    csString = const_cast< const char * >( apBuffer.get() );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
// Reads a byte from the wdaFile
// 
(
 BYTE &bByte // The byte to put the result in.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &bByte, sizeof( bByte ), "a BYTE" );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
// Reads a bool from the wdaFile.
// 
(
 bool &boBool // The bool to put the result in.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Grab a byte to fetch the result from the WDAFile
    BYTE bByte;

    Read( &bByte, sizeof( BYTE ), "a bool" );

    // A bool can only be 0 or 1! The file must be corrupted or the database was not read properly.
    ASSERT( bByte == 0 || bByte == 1 );

    boBool = bByte == 1 ? true : false;
}


//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read 
//////////////////////////////////////////////////////////////////////////////////////////
//  Reads a signed int,
// 
(
 signed int  &nInt // The container signed int
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &nInt, sizeof( signed int ), "an integer" );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
//  Reads from a signed long
// 
(
 signed long &lLong // The long
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &lLong, sizeof( signed long ), "a long" );
}
//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
//  Reads from a signed char.
// 
(
 signed char &cChar // The signed char.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &cChar, sizeof( signed char ), "a char" );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
//  Reads the short.
// 
(
 signed short &sShort // The short.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &sShort, sizeof( signed short ), "a short" );
}

//////////////////////////////////////////////////////////////////////////////////////////
void WDAFile::Read
//////////////////////////////////////////////////////////////////////////////////////////
//  Read a double.
// 
(
 double &dblDouble // The double
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    Read( &dblDouble, sizeof( double ), "a double" );
}